# Entity-based E-commerce Frontend - Copilot Instructions

## Architecture Overview
This frontend is built with **Nuxt.js 3** and follows a traditional component-based architecture, mirroring the entity-based approach of the backend.

## Project Structure
```
pages/           # File-based routing
components/      # Reusable Vue components
stores/          # Pinia stores (state management)
composables/     # Vue composables for shared logic
assets/          # Static assets and styles
public/          # Public static files
```

## Development Guidelines

### Pages Organization
- Organize pages by entity/feature
- Use Nuxt's file-based routing
- Keep pages focused on layout and data fetching

Example page structure:
```
pages/
├── index.vue          # Homepage
├── products/
│   ├── index.vue      # Product listing
│   └── [id].vue       # Product details
├── cart/
│   └── index.vue      # Shopping cart
├── orders/
│   ├── index.vue      # Order history
│   └── [id].vue       # Order details
└── auth/
    ├── login.vue      # Login page
    └── register.vue   # Registration page
```

### Component Architecture
- Create reusable components for each entity
- Use composition API with `<script setup>`
- Follow single responsibility principle

Example component structure:
```vue
<template>
  <div class="product-card">
    <img :src="product.imageUrl" :alt="product.name" />
    <h3>{{ product.name }}</h3>
    <p class="price">${{ product.price }}</p>
    <button @click="addToCart" class="btn-primary">Add to Cart</button>
  </div>
</template>

<script setup lang="ts">
interface Props {
  product: Product
}

const props = defineProps<Props>()
const { addToCart } = useCart()

const addToCart = () => {
  // Add product to cart logic
}
</script>
```

### State Management (Pinia)
- Create stores for each main entity
- Keep store actions simple and focused
- Use composables to wrap store logic

Example store structure:
```typescript
// stores/user.ts
export const useUserStore = defineStore('user', () => {
  const user = ref<User | null>(null)
  const isAuthenticated = computed(() => !!user.value)

  const login = async (credentials: LoginCredentials) => {
    const response = await $fetch('/api/users/login', {
      method: 'POST',
      body: credentials
    })
    user.value = response.user
    // Store token
  }

  const logout = () => {
    user.value = null
    // Clear token
  }

  return {
    user: readonly(user),
    isAuthenticated,
    login,
    logout
  }
})
```

### API Integration
- Use Nuxt's `$fetch` for API calls
- Create composables for API operations
- Handle loading states and errors consistently

Example API composable:
```typescript
// composables/useProducts.ts
export const useProducts = () => {
  const products = ref<Product[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)

  const fetchProducts = async (params?: ProductSearchParams) => {
    loading.value = true
    error.value = null
    
    try {
      const response = await $fetch('/api/products', {
        query: params
      })
      products.value = response.products
    } catch (err) {
      error.value = 'Failed to fetch products'
    } finally {
      loading.value = false
    }
  }

  const createProduct = async (productData: CreateProductRequest) => {
    const response = await $fetch('/api/products', {
      method: 'POST',
      body: productData
    })
    products.value.push(response)
    return response
  }

  return {
    products: readonly(products),
    loading: readonly(loading),
    error: readonly(error),
    fetchProducts,
    createProduct
  }
}
```

### Authentication
- Use Nuxt middleware for route protection
- Store JWT token securely
- Implement automatic token refresh

Example auth middleware:
```typescript
// middleware/auth.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const { isAuthenticated } = useUserStore()
  
  if (!isAuthenticated) {
    return navigateTo('/auth/login')
  }
})
```

### Form Handling
- Use Zod for client-side validation
- Create reusable form components
- Handle validation errors gracefully

Example form component:
```vue
<template>
  <form @submit.prevent="handleSubmit" class="space-y-4">
    <div>
      <label for="email">Email</label>
      <input
        id="email"
        v-model="form.email"
        type="email"
        :class="{ 'error': errors.email }"
      />
      <span v-if="errors.email" class="error-text">{{ errors.email }}</span>
    </div>
    
    <button type="submit" :disabled="loading" class="btn-primary">
      {{ loading ? 'Submitting...' : 'Submit' }}
    </button>
  </form>
</template>

<script setup lang="ts">
import { z } from 'zod'

const schema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters')
})

const form = reactive({
  email: '',
  password: ''
})

const errors = reactive({})
const loading = ref(false)

const handleSubmit = async () => {
  // Validate form
  const result = schema.safeParse(form)
  if (!result.success) {
    // Set validation errors
    return
  }

  loading.value = true
  try {
    // Submit form
    await submitForm(form)
  } catch (error) {
    // Handle submission error
  } finally {
    loading.value = false
  }
}
</script>
```

### Styling Guidelines
- Use Tailwind CSS for styling
- Create utility classes for common patterns
- Keep styling consistent across components

### Error Handling
- Implement global error handler
- Show user-friendly error messages
- Handle network errors gracefully

### Performance Optimization
- Use lazy loading for non-critical components
- Implement proper caching strategies
- Optimize images and assets

### TypeScript Guidelines
- Define interfaces for all data structures
- Use proper type annotations
- Leverage Nuxt's auto-imports

## Key Features to Implement

### Product Catalog
- Product listing with search and filters
- Product detail pages
- Category browsing
- Product reviews and ratings

### Shopping Cart
- Add/remove items
- Update quantities
- Cart persistence
- Cart summary and checkout

### User Management
- User registration and login
- Profile management
- Order history
- Address management

### Order Management
- Order creation and tracking
- Order status updates
- Order details view

## Development Tips
- Keep components focused on presentation
- Use composables for business logic
- Implement proper loading states
- Test components in isolation
- Follow Vue.js best practices

## API Integration Pattern
```typescript
// Entity-based API calls
const { data: products } = await $fetch('/api/products')
const { data: orders } = await $fetch('/api/orders')
const { data: cart } = await $fetch('/api/cart')
```

When working on this entity-based frontend, focus on creating a clean, user-friendly interface that effectively communicates with the entity-based backend. Keep components simple and reusable, and maintain consistency in styling and user experience.
