# Entity-based E-commerce Backend - Copilot Instructions

## Architecture Overview
This backend follows an **Entity-based architecture** pattern, organizing code around database entities using traditional MVC patterns.

## Project Structure
```
src/
├── controllers/     # Business logic organized by entity
├── routes/         # HTTP routes grouped by entity
├── middleware/     # Shared middleware (auth, validation)
└── index.ts       # Express app setup
```

## Coding Guidelines

### Controller Pattern
- Each entity has its own controller class
- Controllers handle HTTP requests and responses
- Business logic is contained within controller methods
- Use dependency injection for database access

Example controller structure:
```typescript
export class UserController {
  async getAll(req: Request, res: Response) {
    // Get all users with pagination
  }
  
  async getById(req: Request, res: Response) {
    // Get single user by ID
  }
  
  async create(req: Request, res: Response) {
    // Create new user with validation
  }
  
  async update(req: Request, res: Response) {
    // Update existing user
  }
  
  async delete(req: Request, res: Response) {
    // Delete user
  }
}
```

### Route Organization
- Group routes by entity type
- Use Express Router for modularity
- Apply middleware at route level
- Follow RESTful conventions

Example route structure:
```typescript
const router = Router();
const userController = new UserController();

// Public routes
router.post('/register', userController.register);
router.post('/login', userController.login);

// Protected routes
router.get('/profile', authMiddleware, userController.getProfile);
router.put('/profile', authMiddleware, userController.updateProfile);
```

### Database Access
- Use Prisma Client directly in controllers
- Implement proper error handling
- Use transactions for complex operations
- Include related data with Prisma's `include`

### Validation
- Use Zod for input validation
- Validate at controller level
- Return consistent error responses
- Handle validation errors gracefully

### Authentication & Authorization
- JWT-based authentication
- Middleware for protected routes
- Role-based access control
- Secure password handling with bcrypt

## API Endpoints

### User Management
- `POST /api/users/register` - User registration
- `POST /api/users/login` - User login
- `GET /api/users/profile` - Get user profile (protected)
- `PUT /api/users/profile` - Update profile (protected)
- `GET /api/users/addresses` - Get user addresses (protected)
- `POST /api/users/addresses` - Create address (protected)

### Product Management
- `GET /api/products` - List products (with pagination/search)
- `GET /api/products/:id` - Get product details
- `GET /api/products/category/:categoryId` - Products by category
- `POST /api/products` - Create product (admin only)
- `PUT /api/products/:id` - Update product (admin only)
- `DELETE /api/products/:id` - Delete product (admin only)

### Order Management
- `GET /api/orders` - Get user orders (protected)
- `GET /api/orders/:id` - Get order details (protected)
- `POST /api/orders` - Create new order (protected)
- `PUT /api/orders/:id/status` - Update order status (protected)

### Cart Management
- `GET /api/cart` - Get user cart (protected)
- `POST /api/cart/add` - Add item to cart (protected)
- `PUT /api/cart/:itemId` - Update cart item (protected)
- `DELETE /api/cart/:itemId` - Remove cart item (protected)
- `DELETE /api/cart` - Clear cart (protected)

## Error Handling
- Use consistent error response format
- Implement global error handler
- Log errors appropriately
- Return appropriate HTTP status codes

```typescript
// Error response format
{
  error: 'Error message',
  details?: any
}
```

## Testing Strategy
- Unit tests for controller methods
- Integration tests for API endpoints
- Mock Prisma client for testing
- Test authentication flows

## Performance Considerations
- Use database indexes for frequently queried fields
- Implement pagination for large datasets
- Use Prisma's query optimization features
- Consider caching for read-heavy operations

## Security Best Practices
- Validate all input data
- Use parameterized queries (Prisma handles this)
- Implement rate limiting
- Secure sensitive endpoints
- Never expose passwords in responses

## Development Tips
- Keep controllers focused on HTTP concerns
- Use service classes for complex business logic
- Implement proper logging
- Use TypeScript strict mode
- Follow consistent naming conventions

When working on this entity-based backend, focus on keeping the code simple and following traditional MVC patterns. Each entity should have clear separation between routes, controllers, and data access.
