# Domain-based E-commerce Frontend - Copilot Instructions

## Architecture Overview
This frontend is built with **Nuxt.js 3** and follows **domain-driven design principles**, organizing features around business domains rather than technical concerns.

## Project Structure
```
pages/           # File-based routing
components/      # Domain-organized components
  ├── user/      # User management components
  ├── product/   # Product catalog components
  ├── order/     # Order processing components
  └── cart/      # Shopping cart components
stores/          # Domain-specific Pinia stores
composables/     # Domain-specific composables
services/        # Domain services (API integration)
types/           # Domain types and interfaces
```

## Domain Organization

### User Domain (`components/user/`, `stores/user.ts`)
**Responsibilities:**
- User authentication and authorization
- Profile management
- Address management
- User preferences

**Components:**
- `UserProfile.vue` - User profile display/edit
- `LoginForm.vue` - Authentication form
- `RegisterForm.vue` - User registration
- `AddressManager.vue` - Address CRUD operations

**Store:**
```typescript
// stores/user.ts
export const useUserStore = defineStore('user', () => {
  // User authentication state
  const currentUser = ref<User | null>(null)
  const isAuthenticated = computed(() => !!currentUser.value)
  
  // User domain actions
  const authenticate = async (credentials: LoginCredentials) => {
    // Authentication logic
  }
  
  const updateProfile = async (profileData: UpdateProfileRequest) => {
    // Profile update logic
  }
  
  const manageAddresses = () => {
    // Address management logic
  }

  return {
    currentUser: readonly(currentUser),
    isAuthenticated,
    authenticate,
    updateProfile,
    manageAddresses
  }
})
```

### Product Domain (`components/product/`, `stores/product.ts`)
**Responsibilities:**
- Product catalog browsing
- Product search and filtering
- Product reviews and ratings
- Category management

**Components:**
- `ProductCatalog.vue` - Product listing with filters
- `ProductDetails.vue` - Detailed product view
- `ProductSearch.vue` - Search functionality
- `ProductReviews.vue` - Review system
- `CategoryBrowser.vue` - Category navigation

**Store:**
```typescript
// stores/product.ts
export const useProductStore = defineStore('product', () => {
  const products = ref<Product[]>([])
  const categories = ref<Category[]>([])
  const searchResults = ref<Product[]>([])
  
  const browseProducts = async (filters: ProductFilters) => {
    // Product browsing logic
  }
  
  const searchProducts = async (query: string) => {
    // Product search logic
  }
  
  const getProductDetails = async (productId: string) => {
    // Product detail fetching
  }

  return {
    products: readonly(products),
    categories: readonly(categories),
    searchResults: readonly(searchResults),
    browseProducts,
    searchProducts,
    getProductDetails
  }
})
```

### Order Domain (`components/order/`, `stores/order.ts`)
**Responsibilities:**
- Order creation and processing
- Order tracking and status
- Order history
- Payment processing

**Components:**
- `OrderSummary.vue` - Order review before checkout
- `OrderTracking.vue` - Order status tracking
- `OrderHistory.vue` - Past orders display
- `CheckoutFlow.vue` - Multi-step checkout process

**Store:**
```typescript
// stores/order.ts
export const useOrderStore = defineStore('order', () => {
  const currentOrder = ref<Order | null>(null)
  const orderHistory = ref<Order[]>([])
  
  const createOrder = async (orderData: CreateOrderRequest) => {
    // Order creation workflow
  }
  
  const trackOrder = async (orderId: string) => {
    // Order tracking logic
  }
  
  const getOrderHistory = async () => {
    // Order history retrieval
  }

  return {
    currentOrder: readonly(currentOrder),
    orderHistory: readonly(orderHistory),
    createOrder,
    trackOrder,
    getOrderHistory
  }
})
```

### Cart Domain (`components/cart/`, `stores/cart.ts`)
**Responsibilities:**
- Shopping cart management
- Cart item operations
- Cart persistence
- Cart-to-order conversion

**Components:**
- `ShoppingCart.vue` - Main cart interface
- `CartItem.vue` - Individual cart item
- `CartSummary.vue` - Cart totals and summary
- `QuickAddToCart.vue` - Quick add functionality

**Store:**
```typescript
// stores/cart.ts
export const useCartStore = defineStore('cart', () => {
  const cartItems = ref<CartItem[]>([])
  const cartTotal = computed(() => 
    cartItems.value.reduce((total, item) => total + (item.price * item.quantity), 0)
  )
  
  const addToCart = (product: Product, quantity: number = 1) => {
    // Add item to cart logic
  }
  
  const updateCartItem = (itemId: string, quantity: number) => {
    // Update cart item logic
  }
  
  const removeFromCart = (itemId: string) => {
    // Remove item logic
  }
  
  const convertToOrder = () => {
    // Convert cart to order
  }

  return {
    cartItems: readonly(cartItems),
    cartTotal,
    addToCart,
    updateCartItem,
    removeFromCart,
    convertToOrder
  }
})
```

## Domain Services

### API Services by Domain
```typescript
// services/userService.ts
export class UserService {
  async authenticate(credentials: LoginCredentials): Promise<AuthResponse> {
    return await $fetch('/api/users/login', {
      method: 'POST',
      body: credentials
    })
  }
  
  async updateProfile(profileData: UpdateProfileRequest): Promise<User> {
    return await $fetch('/api/users/profile', {
      method: 'PUT',
      body: profileData
    })
  }
}

// services/productService.ts
export class ProductService {
  async getProducts(filters: ProductFilters): Promise<ProductResponse> {
    return await $fetch('/api/products', {
      query: filters
    })
  }
  
  async searchProducts(query: string): Promise<Product[]> {
    return await $fetch('/api/products/search', {
      query: { q: query }
    })
  }
}
```

## Domain Types

### User Domain Types
```typescript
// types/user.ts
export interface User {
  id: string
  email: string
  firstName: string
  lastName: string
  role: UserRole
}

export interface LoginCredentials {
  email: string
  password: string
}

export interface UpdateProfileRequest {
  firstName?: string
  lastName?: string
}

export enum UserRole {
  CUSTOMER = 'CUSTOMER',
  ADMIN = 'ADMIN'
}
```

### Product Domain Types
```typescript
// types/product.ts
export interface Product {
  id: string
  name: string
  description: string
  price: number
  imageUrl: string
  category: Category
}

export interface ProductFilters {
  categoryId?: string
  priceRange?: PriceRange
  searchQuery?: string
  sortBy?: ProductSortBy
}

export interface Category {
  id: string
  name: string
  description: string
}
```

## Component Patterns

### Domain-specific Component Structure
```vue
<!-- components/product/ProductCatalog.vue -->
<template>
  <div class="product-catalog">
    <ProductFilters @filter-change="handleFilterChange" />
    <ProductGrid :products="filteredProducts" :loading="loading" />
    <ProductPagination 
      :current-page="currentPage" 
      :total-pages="totalPages"
      @page-change="handlePageChange" 
    />
  </div>
</template>

<script setup lang="ts">
// Focus on product domain logic
const { products, loading, browseProducts } = useProductStore()
const { filters, updateFilters } = useProductFilters()

const filteredProducts = computed(() => {
  // Product filtering logic specific to product domain
})

const handleFilterChange = (newFilters: ProductFilters) => {
  updateFilters(newFilters)
  browseProducts(newFilters)
}
</script>
```

### Cross-Domain Communication
```typescript
// Composables for cross-domain interactions
export const useCartIntegration = () => {
  const cartStore = useCartStore()
  const productStore = useProductStore()
  
  const addProductToCart = async (productId: string, quantity: number) => {
    const product = await productStore.getProductDetails(productId)
    cartStore.addToCart(product, quantity)
  }
  
  return {
    addProductToCart
  }
}
```

## Page Organization by Domain

### Domain-focused Pages
```
pages/
├── index.vue                 # Homepage (cross-domain)
├── user/
│   ├── profile.vue          # User profile management
│   ├── addresses.vue        # Address management
│   └── settings.vue         # User preferences
├── products/
│   ├── index.vue            # Product catalog
│   ├── [id].vue             # Product details
│   └── search.vue           # Product search
├── orders/
│   ├── index.vue            # Order history
│   ├── [id].vue             # Order details
│   └── checkout.vue         # Checkout process
└── cart.vue                 # Shopping cart
```

## State Management Strategy

### Domain Boundaries
- Each domain has its own store
- Cross-domain communication through composables
- Shared state for cross-cutting concerns

### Example Cross-Domain Workflow
```typescript
// User adds product to cart, then creates order
const { addToCart } = useCartStore()
const { createOrder } = useOrderStore()
const { currentUser } = useUserStore()

// 1. Add to cart (Product → Cart domains)
await addToCart(product, quantity)

// 2. Create order (Cart → Order → User domains)
const orderData = {
  userId: currentUser.value.id,
  items: cartItems.value,
  shippingAddress: currentUser.value.defaultAddress
}
await createOrder(orderData)
```

## Development Guidelines

### Domain Isolation
- Keep domain logic separate
- Use interfaces for cross-domain communication
- Avoid tight coupling between domains

### Business-First Approach
- Think in terms of user workflows
- Organize by business capabilities
- Focus on user value delivery

### Testing Strategy
- Test domain logic in isolation
- Mock cross-domain dependencies
- Test user workflows end-to-end

## Best Practices

1. **Maintain domain boundaries** - Each domain should be self-contained
2. **Use domain language** - Name components and functions using business terms
3. **Focus on user journeys** - Organize features around user goals
4. **Implement clean interfaces** - Define clear contracts between domains
5. **Keep business logic separate** - Don't mix domain logic with UI concerns

When working on this domain-based frontend, always consider which domain you're working in and how it relates to the user's business needs. Focus on creating intuitive user experiences that reflect the underlying business domains.
