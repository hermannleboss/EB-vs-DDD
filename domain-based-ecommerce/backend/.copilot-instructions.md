# Domain-based E-commerce Backend - Copilot Instructions

## Architecture Overview
This backend follows **Domain-Driven Design (DDD)** principles, organizing code around business domains with clean architecture layers.

## Project Structure
```
src/
├── domains/
│   ├── user/
│   │   ├── domain/          # Business entities & interfaces
│   │   ├── application/     # Use cases & services
│   │   └── infrastructure/  # External concerns (routes, DB)
│   ├── product/
│   ├── order/
│   └── cart/
└── index.ts               # Express app setup
```

## Clean Architecture Layers

### Domain Layer (`domain/`)
- **Pure business logic** - no external dependencies
- Contains entities, value objects, domain services
- Defines repository interfaces
- Implements business rules and validations

```typescript
// entities.ts
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: 'CUSTOMER' | 'ADMIN';
}

// repositories.ts
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  save(user: CreateUserRequest): Promise<User>;
}
```

### Application Layer (`application/`)
- **Use cases and application services**
- Orchestrates domain objects
- Contains business workflows
- Defines DTOs and commands

```typescript
export class UserService {
  constructor(
    private userRepository: UserRepository,
    private authService: AuthService
  ) {}

  async registerUser(request: RegisterUserRequest): Promise<User> {
    // Use case implementation
    // 1. Validate input
    // 2. Check if user exists
    // 3. Hash password
    // 4. Save user
    // 5. Return user
  }
}
```

### Infrastructure Layer (`infrastructure/`)
- **External concerns** - HTTP, database, external APIs
- Implements repository interfaces
- Contains route handlers
- Handles serialization/deserialization

```typescript
// routes.ts
export const userRoutes = Router();

userRoutes.post('/register', async (req, res) => {
  const userService = new UserService(userRepository, authService);
  const result = await userService.registerUser(req.body);
  res.json(result);
});
```

## Domain Guidelines

### User Domain
**Responsibilities:**
- User registration and authentication
- Profile management
- Address management
- Role-based permissions

**Key entities:** User, Address
**Key use cases:** Register, Login, UpdateProfile, ManageAddresses

### Product Domain
**Responsibilities:**
- Product catalog management
- Category management
- Product search and filtering
- Inventory tracking

**Key entities:** Product, Category
**Key use cases:** CreateProduct, UpdateProduct, SearchProducts, ManageInventory

### Order Domain
**Responsibilities:**
- Order processing workflow
- Order status management
- Order history
- Payment integration

**Key entities:** Order, OrderItem
**Key use cases:** CreateOrder, UpdateOrderStatus, GetOrderHistory, ProcessPayment

### Cart Domain
**Responsibilities:**
- Shopping cart management
- Cart item operations
- Cart persistence
- Cart-to-order conversion

**Key entities:** Cart, CartItem
**Key use cases:** AddToCart, UpdateCartItem, RemoveFromCart, ConvertToOrder

## Coding Patterns

### Repository Pattern
```typescript
// Domain layer interface
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<User>;
}

// Infrastructure layer implementation
export class PrismaUserRepository implements UserRepository {
  constructor(private prisma: PrismaClient) {}
  
  async findById(id: string): Promise<User | null> {
    return await this.prisma.user.findUnique({ where: { id } });
  }
}
```

### Dependency Injection
```typescript
// Application service
export class UserService {
  constructor(
    private userRepository: UserRepository,
    private authService: AuthService
  ) {}
}

// Infrastructure setup
const userRepository = new PrismaUserRepository(prisma);
const authService = new JwtAuthService();
const userService = new UserService(userRepository, authService);
```

### Use Case Pattern
```typescript
export class RegisterUserUseCase {
  constructor(
    private userRepository: UserRepository,
    private authService: AuthService
  ) {}

  async execute(request: RegisterUserRequest): Promise<RegisterUserResponse> {
    // 1. Validate input
    const validation = this.validateInput(request);
    if (!validation.isValid) {
      throw new ValidationError(validation.errors);
    }

    // 2. Check business rules
    const existingUser = await this.userRepository.findByEmail(request.email);
    if (existingUser) {
      throw new DomainError('User already exists');
    }

    // 3. Create user
    const hashedPassword = await this.authService.hashPassword(request.password);
    const user = await this.userRepository.save({
      ...request,
      password: hashedPassword
    });

    // 4. Generate token
    const token = this.authService.generateToken(user.id);

    return { user, token };
  }
}
```

## API Design

### Domain-based Endpoints
Each domain exposes its own API endpoints:

**User Domain:**
- `POST /api/users/register`
- `POST /api/users/login`
- `GET /api/users/profile`
- `PUT /api/users/profile`

**Product Domain:**
- `GET /api/products`
- `GET /api/products/:id`
- `POST /api/products` (admin)

**Order Domain:**
- `GET /api/orders`
- `POST /api/orders`
- `GET /api/orders/:id`

**Cart Domain:**
- `GET /api/cart`
- `POST /api/cart/items`
- `PUT /api/cart/items/:id`

## Error Handling
```typescript
// Domain errors
export class DomainError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'DomainError';
  }
}

export class ValidationError extends Error {
  constructor(public errors: string[]) {
    super('Validation failed');
    this.name = 'ValidationError';
  }
}

// Infrastructure error handling
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  if (err instanceof ValidationError) {
    return res.status(400).json({ error: err.message, details: err.errors });
  }
  
  if (err instanceof DomainError) {
    return res.status(400).json({ error: err.message });
  }
  
  // Generic error
  res.status(500).json({ error: 'Internal server error' });
});
```

## Testing Strategy
- **Unit tests** for domain logic (entities, services)
- **Integration tests** for use cases
- **API tests** for infrastructure layer
- **Mock external dependencies** (database, external APIs)

## Best Practices
1. **Keep domain layer pure** - no external dependencies
2. **Use dependency injection** for loose coupling
3. **Implement repository interfaces** in domain layer
4. **Keep use cases focused** on single business operation
5. **Separate DTOs** from domain entities
6. **Use value objects** for complex data types
7. **Implement proper error handling** at each layer

## Development Tips
- Start with domain layer (entities, interfaces)
- Implement use cases in application layer
- Add infrastructure last (routes, database)
- Focus on business rules first, technical details later
- Use interfaces for all external dependencies
- Keep each domain independent

When working on this domain-based backend, always think about which domain you're working in and ensure you're following the clean architecture principles. Keep business logic separate from infrastructure concerns.
